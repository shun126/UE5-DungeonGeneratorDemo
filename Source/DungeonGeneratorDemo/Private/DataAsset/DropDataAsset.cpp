/**
@author		Shun Moriya



https://historia.co.jp/archives/13665/
*/

#include "DataAsset/DropDataAsset.h"
#include <Math/RandomStream.h>
#include <UObject/ObjectSaveContext.h>

#if WITH_EDITOR
#include <Misc/FileHelper.h>
#include <Misc/MessageDialog.h>
#endif

//! 無効なアイテムドロップデータ
FDropData UDropDataAsset::mInvalidDropData;

void UDropDataAsset::Build()
{
#if WITH_EDITORONLY_DATA
	// データテーブルの設定チェック
	if (DataTable == nullptr)
	{
		const FText title = FText::FromString(TEXT("DropDataAsset Error"));
		const FText body = FText::FromString(TEXT("DropDataTable is Null !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return;
	}

	// データテーブルの型チェック
	if (!DataTable->GetRowStruct()->IsChildOf(FDropTableRow::StaticStruct()))
	{
		const FText title = FText::FromString(TEXT("DropDataAsset Error"));
		const FText body = FText::FromString(TEXT("DropDataTable type does not match !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
	}

#if 0
	// データテーブルをリインポート
	TArray<UPackage*> PackagesToSave;
	if (FReimportManager::Instance()->Reimport(DataTable, false, true))
	{
		// リインポートに成功したデータテーブルを保存対象に追加
		PackagesToSave.Add(DataTable->GetOutermost());
	}
#endif

	// データテーブルの行の要素を配列で取得
	Data.Empty();
	Map.Empty();
	const auto& Names = DataTable->GetRowNames();
	for (int32 i = 0; i < Names.Num(); ++i)
	{
		auto record = DataTable->FindRow<FDropTableRow>(Names[i], FString());
		if (record == nullptr)
			continue;

		FDropData data;
		data.Name = Names[i].ToString();
		data.DropObjects = record->DropObjects;

		float dropTotalRate = 0.f;
		for (auto& dropObject : data.DropObjects)
		{
			dropTotalRate += dropObject.Rate;
			dropObject.Rate = dropTotalRate ;
		}
		if (dropTotalRate != 0.f)
		{
			for (auto& dropObject : data.DropObjects)
				dropObject.Rate /= dropTotalRate;
		}

		Data.Add(data);
		Map.Add(data.Name, static_cast<EDropDataId>(i));
	}

	if (!GenerateEnumHeader(Names))
		return;

	// データアセットに編集フラグを追加
	MarkPackageDirty();
#if 0
	// データアセットを保存対象に追加
	PackagesToSave.Add(GetOutermost());

	// 関連アセットを全て保存（SourceControl使用時はチェックアウトするかメッセージウィンドウを出す）
	// ファイル編集フラグ（Dirty)が付いてるもののみを保存対象にしたいので第一引数はtrue
	// 保存する際に確認のメッセージウィンドウを出さない場合は第二引数をfalseにする
	FEditorFileUtils::PromptForCheckoutAndSave(PackagesToSave, true, true); 
#endif
#endif
}

bool UDropDataAsset::GenerateEnumHeader(const TArray<FName>& names) const
{
#if WITH_EDITORONLY_DATA
	if (OutputHeaderPath.IsEmpty())
	{
		const FText title = FText::FromString(TEXT("DataAsset Error"));
		const FText body = FText::FromString(TEXT("No item drop data asset header name."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}

	FString pathPart, filenamePart, extensionPart;
	FPaths::Split(OutputHeaderPath, pathPart, filenamePart, extensionPart);

	TArray<FString> output;
	output.Add(TEXT("/*"));
	output.Add(TEXT("This is automatically generated file."));
	output.Add(TEXT("DO NOT EDIT THIS FILE."));
	output.Add(TEXT("*/"));
	output.Add(TEXT("#pragma once"));
	output.Add(TEXT("#include <CoreMinimal.h>"));
	output.Add(TEXT("UENUM(BlueprintType)"));
	output.Add(TEXT("enum class E") + filenamePart + TEXT(" : uint8"));
	output.Add(TEXT("{"));

	for (int32 i = 0; i < names.Num(); ++i)
	{
		output.Add(TEXT("	") + names[i].ToString() + TEXT(","));
	}

	output.Add(TEXT("	Invalid"));
	output.Add(TEXT("};"));
	output.Add(TEXT("static constexpr uint8 ") + filenamePart + TEXT("Size = static_cast<uint8>(E") + filenamePart + TEXT("::Invalid);"));
	output.Add(TEXT("inline bool IsInvalid(const E") + filenamePart + TEXT(" id) { return static_cast<uint8>(id) >= ") + filenamePart + TEXT("Size; }"));

	const FString outputHeaderPath = FPaths::GameSourceDir() + OutputHeaderPath;
	if (!FFileHelper::SaveStringArrayToFile(output, *outputHeaderPath, FFileHelper::EEncodingOptions::ForceUTF8))
	{
		const FText title = FText::FromString(TEXT("DataAsset Error"));
		const FText body = FText::FromString(TEXT("Write item drop data asset header failed."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}
#endif

	return true;
}

const FDropData& UDropDataAsset::Get(const EDropDataId id) const
{
	if (static_cast<size_t>(id) >= static_cast<size_t>(EDropDataId::Invalid))
		return mInvalidDropData;
	else
		return Data[static_cast<size_t>(id)];
}

const FDropData& UDropDataAsset::Find(const FString& name) const
{
	const EDropDataId* id = Map.Find(name);
	if (id == nullptr)
		return mInvalidDropData;
	else
		return Data[static_cast<size_t>(*id)];
}

TSubclassOf<AStockable> UDropDataAsset::Draw(const EDropDataId id) const
{
	static FRandomStream randomStream;

	if (id == EDropDataId::Invalid)
		return TSubclassOf<AStockable>();

	const auto draw = randomStream.GetFraction();
	const auto& data = Get(id);
	for (const auto& dropObject : data.DropObjects)
	{
		if (draw <= dropObject.Rate)
			return dropObject.DropObject;
	}

	return TSubclassOf<AStockable>();
}

void UDropDataAsset::PreSave(FObjectPreSaveContext SaveContext)
{
	Super::PreSave(SaveContext);

#if WITH_EDITOR
	if (IsRunningCookCommandlet())
	{
		Build();
	}
#endif
}
