/**
@author		Shun Moriya
https://historia.co.jp/archives/13665/
*/

#include "DataAsset/ItemDataAsset.h"
#include "DataAssetHelper.h"
#include <Internationalization/StringTable.h>

#if WITH_EDITOR
#include <Misc/FileHelper.h>
#include <Misc/MessageDialog.h>
#endif

//! 無効なアイテムデータ
FItemData UItemDataAsset::mInvalidItemData;

FText FItemData::GetName() const
{
	if (mOwnerAsset && mOwnerAsset->GetStringTable())
	{
		return FText::FromStringTable(
			mOwnerAsset->GetStringTable()->GetStringTableId(),
			Name + TEXT("_Name"),
			EStringTableLoadingPolicy::FindOrFullyLoad
		);
	}

	return FText();
}

FText FItemData::GetDescription() const
{
	if (mOwnerAsset && mOwnerAsset->GetStringTable())
	{
		return FText::FromStringTable(
			mOwnerAsset->GetStringTable()->GetStringTableId(),
			Name + TEXT("_Description"),
			EStringTableLoadingPolicy::FindOrFullyLoad
		);
	}

	return FText();
}

const UStringTable* UItemDataAsset::GetStringTable() const
{
	return StringTable;
}

void UItemDataAsset::Build()
{
#if WITH_EDITORONLY_DATA
	// データテーブルの設定チェック
	if (DataTable == nullptr)
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("ItemDataTable is Null !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return;
	}
	
	// データテーブルの型チェック
	if(!DataTable->GetRowStruct()->IsChildOf(FItemTableRow::StaticStruct()))
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("ItemDataTable type does not match !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
	}

#if 0
	// データテーブルをリインポート
	TArray<UPackage*> PackagesToSave;
	if (FReimportManager::Instance()->Reimport(DataTable, false, true))
	{
		// リインポートに成功したデータテーブルを保存対象に追加
		PackagesToSave.Add(DataTable->GetOutermost());
	}
#endif

	// データテーブルの行の要素を配列で取得
	Data.Empty();
	Map.Empty();
	const TArray<FName>& Names = DataTable->GetRowNames();
	for (int32 i = 0; i < Names.Num(); ++i)
	{
		const auto record = DataTable->FindRow<FItemTableRow>(Names[i], FString());
		if (record == nullptr)
			continue;

		FItemData data;
		data.Name = Names[i].ToString();
		data.SellingPrice = record->SellingPrice;
		data.CanUseInMenu = record->CanUseInMenu;
		data.CanDropFromMenu = record->CanDropFromMenu;
		data.CanDropFromEnemy = record->CanDropFromEnemy;
		if (record->ActorPath.IsValid())
		{
			const FSoftObjectPath path(record->ActorPath.ToString() + "_C");
			TSoftClassPtr<AActor> softClassPointer(path);
			//TSoftClassPtr<AActor> softClassPointer(record->ActorPath);
			data.ActorClass = softClassPointer.LoadSynchronous();
		}

		Data.Add(data);
		Map.Add(data.Name, static_cast<EItemDataId>(i));
	}
	
	if (!GenerateEnumHeader(Names))
		return;
	if (!GenerateStringTableCsv(Names))
		return;	

	// データアセットに編集フラグを追加
	MarkPackageDirty();

#if 0
	// データアセットを保存対象に追加
	PackagesToSave.Add(GetOutermost());

	// 関連アセットを全て保存（SourceControl使用時はチェックアウトするかメッセージウィンドウを出す）
	// ファイル編集フラグ（Dirty)が付いてるもののみを保存対象にしたいので第一引数はtrue
	// 保存する際に確認のメッセージウィンドウを出さない場合は第二引数をfalseにする
	FEditorFileUtils::PromptForCheckoutAndSave(PackagesToSave, true, true); 
#endif
#endif
}

bool UItemDataAsset::GenerateEnumHeader(const TArray<FName>& names) const
{
#if WITH_EDITORONLY_DATA
	if (OutputHeaderPath.IsEmpty())
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("No item data asset header name."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}

	FString pathPart, filenamePart, extensionPart;
	FPaths::Split(OutputHeaderPath, pathPart, filenamePart, extensionPart);

	TArray<FString> output;
	output.Add(TEXT("/*"));
	output.Add(TEXT("This is automatically generated file."));
	output.Add(TEXT("DO NOT EDIT THIS FILE."));
	output.Add(TEXT("*/"));
	output.Add(TEXT("#pragma once"));
	output.Add(TEXT("#include <CoreMinimal.h>"));
	output.Add(TEXT("UENUM(BlueprintType)"));
	output.Add(TEXT("enum class E") + filenamePart + TEXT(" : uint8"));
	output.Add(TEXT("{"));

	for (int32 i = 0; i < names.Num(); ++i)
	{
		output.Add(TEXT("	") + names[i].ToString() + TEXT(","));
	}

	output.Add(TEXT("	Invalid"));
	output.Add(TEXT("};"));
	output.Add(TEXT("static constexpr uint8 ") + filenamePart + TEXT("Size = static_cast<uint8>(E") + filenamePart + TEXT("::Invalid);"));
	output.Add(TEXT("inline bool IsInvalid(const E") + filenamePart + TEXT(" id) { return static_cast<uint8>(id) >= ") + filenamePart + TEXT("Size; }"));

	const FString outputPath = FPaths::GameSourceDir() + OutputHeaderPath;
	if (!FFileHelper::SaveStringArrayToFile(output, *outputPath, FFileHelper::EEncodingOptions::ForceUTF8))
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("Write item data asset header failed."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}
#endif

	return true;
}

bool UItemDataAsset::GenerateStringTableCsv(const TArray<FName>& names) const
{
#if WITH_EDITORONLY_DATA
	if (OutputStringTableCsvPath.IsEmpty())
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("No item string table csv name."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}

	FString pathPart, filenamePart, extensionPart;
	FPaths::Split(OutputStringTableCsvPath, pathPart, filenamePart, extensionPart);
	const FString outputPath = FPaths::ProjectContentDir() + OutputStringTableCsvPath;

	TArray<FString> output;

	if (FFileHelper::LoadFileToStringArray(output, *outputPath))
	{
		for (int32 i = 0; i < names.Num(); ++i)
		{
			const FString& name = names[i].ToString();
			if (DungeonGenerator::DataAsset::ContainsInStringArray(output, name) == false)
			{
				output.Add(TEXT("\"") + name + TEXT("_Name\", \"\""));
				output.Add(TEXT("\"") + name + TEXT("_Description\", \"\""));
			}
		}
	}
	else
	{
		output.Add(TEXT("Key,SourceString"));

		for (int32 i = 0; i < names.Num(); ++i)
		{
			output.Add(TEXT("\"") + names[i].ToString() + TEXT("_Name\", \"\""));
			output.Add(TEXT("\"") + names[i].ToString() + TEXT("_Description\", \"\""));
		}
	}

	if (!FFileHelper::SaveStringArrayToFile(output, *outputPath, FFileHelper::EEncodingOptions::ForceUTF8))
	{
		const FText title = FText::FromString(TEXT("ItemDataAsset Error"));
		const FText body = FText::FromString(TEXT("Write item string table csv failed."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}
#endif

	return true;
}

const FItemData& UItemDataAsset::Get(const EItemDataId id) const
{
	if (static_cast<size_t>(id) >= static_cast<size_t>(EItemDataId::Invalid))
		return mInvalidItemData;

	const auto* data = &Data[static_cast<size_t>(id)];
	const_cast<FItemData*>(data)->mOwnerAsset = this;
	return *data;
}

const FItemData& UItemDataAsset::Find(const FString& name) const
{
	const EItemDataId* id = Map.Find(name);
	if (id == nullptr)
		return mInvalidItemData;

	const auto* data = &Data[static_cast<size_t>(*id)];
	const_cast<FItemData*>(data)->mOwnerAsset = this;
	return *data;
}

const FItemData& UItemDataAsset::Invalid()
{
	return mInvalidItemData;
}
