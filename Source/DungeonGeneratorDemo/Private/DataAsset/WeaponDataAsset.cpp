/**
@author		Shun Moriya
https://historia.co.jp/archives/13665/
*/

#include "DataAsset/WeaponDataAsset.h"
#include "DataAssetHelper.h"
#include <Internationalization/StringTable.h>

#if WITH_EDITOR
#include <Misc/FileHelper.h>
#include <Misc/MessageDialog.h>
#endif

//! 無効な武器データ
FWeaponData UWeaponDataAsset::mInvalidWeaponData;

FText FWeaponData::GetName() const
{
	if (mOwnerAsset && mOwnerAsset->GetStringTable())
	{
		return FText::FromStringTable(
			mOwnerAsset->GetStringTable()->GetStringTableId(),
			Name + TEXT("_Name"),
			EStringTableLoadingPolicy::FindOrFullyLoad
		);
	}

	return FText();
}

FText FWeaponData::GetDescription() const
{
	if (mOwnerAsset && mOwnerAsset->GetStringTable())
	{
		return FText::FromStringTable(
			mOwnerAsset->GetStringTable()->GetStringTableId(),
			Name + TEXT("_Description"),
			EStringTableLoadingPolicy::FindOrFullyLoad
		);
	}

	return FText();
}

const UStringTable* UWeaponDataAsset::GetStringTable() const
{
	return StringTable;
}

void UWeaponDataAsset::Build()
{
#if WITH_EDITORONLY_DATA
	// データテーブルの設定チェック
	if (DataTable == nullptr)
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("WeaponDataTable is Null !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return;
	}

	// データテーブルの型チェック
	if (!DataTable->GetRowStruct()->IsChildOf(FWeaponTableRow::StaticStruct()))
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("WeaponDataTable type does not match !!"));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
	}

#if 0
	// データテーブルをリインポート
	TArray<UPackage*> PackagesToSave;
	if (FReimportManager::Instance()->Reimport(DataTable, false, true))
	{
		// リインポートに成功したデータテーブルを保存対象に追加
		PackagesToSave.Add(DataTable->GetOutermost());
	}
#endif

	// データテーブルの行の要素を配列で取得
	Data.Empty();
	Map.Empty();
	const auto& Names = DataTable->GetRowNames();
	for (int32 i = 0; i < Names.Num(); ++i)
	{
		auto record = DataTable->FindRow<FWeaponTableRow>(Names[i], FString());
		if (record == nullptr)
			continue;

		FWeaponData data;
		data.Name = Names[i].ToString();
		data.WeaponAnimationType = record->WeaponAnimationType;
		data.Bullet = record->Bullet;
		data.Range = record->Range;
		data.AttackPower = record->AttackPower;
		data.SellingPrice = record->SellingPrice;
		if (record->PlacedActorPath.IsValid())
		{
			const FSoftObjectPath path(record->PlacedActorPath.ToString() + "_C");
			TSoftClassPtr<AActor> softClassPointer(path);
			data.PlacedActorClass = softClassPointer.LoadSynchronous();
		}
		if (record->EquippedActorPath.IsValid())
		{
			const FSoftObjectPath path(record->EquippedActorPath.ToString() + "_C");
			TSoftClassPtr<AActor> softClassPointer(path);
			data.EquippedActorClass = softClassPointer.LoadSynchronous();
		}

		Data.Add(data);
		Map.Add(data.Name, static_cast<EWeaponDataId>(i));
	}

	if (!GenerateEnumHeader(Names))
		return;
	if (!GenerateStringTableCsv(Names))
		return;

	// データアセットに編集フラグを追加
	MarkPackageDirty();
#if 0
	// データアセットを保存対象に追加
	PackagesToSave.Add(GetOutermost());

	// 関連アセットを全て保存（SourceControl使用時はチェックアウトするかメッセージウィンドウを出す）
	// ファイル編集フラグ（Dirty)が付いてるもののみを保存対象にしたいので第一引数はtrue
	// 保存する際に確認のメッセージウィンドウを出さない場合は第二引数をfalseにする
	FEditorFileUtils::PromptForCheckoutAndSave(PackagesToSave, true, true); 
#endif
#endif
}

bool UWeaponDataAsset::GenerateEnumHeader(const TArray<FName>& names) const
{
#if WITH_EDITORONLY_DATA
	if (OutputHeaderPath.IsEmpty())
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("No weapon data asset header name."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}

	FString pathPart, filenamePart, extensionPart;
	FPaths::Split(OutputHeaderPath, pathPart, filenamePart, extensionPart);

	TArray<FString> output;
	output.Add(TEXT("/*"));
	output.Add(TEXT("This is automatically generated file."));
	output.Add(TEXT("DO NOT EDIT THIS FILE."));
	output.Add(TEXT("*/"));
	output.Add(TEXT("#pragma once"));
	output.Add(TEXT("#include <CoreMinimal.h>"));
	output.Add(TEXT("UENUM(BlueprintType)"));
	output.Add(TEXT("enum class E") + filenamePart + TEXT(" : uint8"));
	output.Add(TEXT("{"));

	for (int32 i = 0; i < names.Num(); ++i)
	{
		output.Add(TEXT("	") + names[i].ToString() + TEXT(","));
	}

	output.Add(TEXT("	Invalid"));
	output.Add(TEXT("};"));
	output.Add(TEXT("static constexpr uint8 ") + filenamePart + TEXT("Size = static_cast<uint8>(E") + filenamePart + TEXT("::Invalid);"));
	output.Add(TEXT("inline bool IsInvalid(const E") + filenamePart + TEXT(" id) { return static_cast<uint8>(id) >= ") + filenamePart + TEXT("Size; }"));

	const FString outputHeaderPath = FPaths::GameSourceDir() + OutputHeaderPath;
	if (!FFileHelper::SaveStringArrayToFile(output, *outputHeaderPath, FFileHelper::EEncodingOptions::ForceUTF8))
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("Write weapon data asset header failed."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}
#endif

	return true;
}

bool UWeaponDataAsset::GenerateStringTableCsv(const TArray<FName>& names) const
{
#if WITH_EDITORONLY_DATA
	if (OutputStringTableCsvPath.IsEmpty())
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("No weapon string table csv name."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}

	FString pathPart, filenamePart, extensionPart;
	FPaths::Split(OutputStringTableCsvPath, pathPart, filenamePart, extensionPart);
	const FString outputPath = FPaths::ProjectContentDir() + OutputStringTableCsvPath;

	TArray<FString> output;

	if (FFileHelper::LoadFileToStringArray(output, *outputPath))
	{
		for (int32 i = 0; i < names.Num(); ++i)
		{
			const FString& name = names[i].ToString();
			if (DungeonGenerator::DataAsset::ContainsInStringArray(output, name) == false)
			{
				output.Add(TEXT("\"") + name + TEXT("_Name\", \"\""));
				output.Add(TEXT("\"") + name + TEXT("_Description\", \"\""));
			}
		}
	}
	else
	{
		output.Add(TEXT("Key,SourceString"));

		for (int32 i = 0; i < names.Num(); ++i)
		{
			output.Add(TEXT("\"") + names[i].ToString() + TEXT("_Name\",\"\""));
			output.Add(TEXT("\"") + names[i].ToString() + TEXT("_Description\",\"\""));
		}
	}

	if (!FFileHelper::SaveStringArrayToFile(output, *outputPath, FFileHelper::EEncodingOptions::ForceUTF8))
	{
		const FText title = FText::FromString(TEXT("WeaponDataAsset Error"));
		const FText body = FText::FromString(TEXT("Write weapon string table csv failed."));
		FMessageDialog::Open(EAppMsgType::Ok, body, &title);
		return false;
	}
#endif

	return true;
}

const FWeaponData& UWeaponDataAsset::Get(const EWeaponDataId id) const
{
	if (static_cast<size_t>(id) >= static_cast<size_t>(EWeaponDataId::Invalid))
		return mInvalidWeaponData;

	const auto* data = &Data[static_cast<size_t>(id)];
	const_cast<FWeaponData*>(data)->mOwnerAsset = this;
	return *data;
}

const FWeaponData& UWeaponDataAsset::Find(const FString& name) const
{
	const EWeaponDataId* id = Map.Find(name);
	if (id == nullptr)
		return mInvalidWeaponData;

	const auto* data = &Data[static_cast<size_t>(*id)];
	const_cast<FWeaponData*>(data)->mOwnerAsset = this;
	return *data;
}
